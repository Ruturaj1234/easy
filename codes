#include <iostream>
#include <algorithm>
using namespace std;

// Linear Search
int linearSearch(string a[], int n, string key) {
    for (int i = 0; i < n; i++)
        if (a[i] == key) return i;
    return -1;
}

// Binary Search
int binarySearch(string a[], int n, string key) {
    int low = 0, high = n - 1;
    while (low <= high) {
        int mid = (low + high) / 2;
        if (a[mid] == key) return mid;
        else if (a[mid] < key) low = mid + 1;
        else high = mid - 1;
    }
    return -1;
}

int main() {
    string movies[] = {"Avatar", "Inception", "Titanic", "Jaws", "Gladiator"};
    int n = 5;
    string searchMovie = "Titanic";

    // Unsorted list → Linear Search
    int lin = linearSearch(movies, n, searchMovie);

    // Sorted list → Binary Search
    sort(movies, movies + n);
    int bin = binarySearch(movies, n, searchMovie);

    cout << "Linear Search Position: " << lin << endl;
    cout << "Binary Search Position: " << bin << endl;

    return 0;
}







#include <iostream>
#include <ctime>
using namespace std;

void bubbleSort(int a[], int n) {
    for(int i=0;i<n-1;i++)
        for(int j=0;j<n-i-1;j++)
            if(a[j]>a[j+1])
                swap(a[j],a[j+1]);
}

void selectionSort(int a[], int n) {
    for(int i=0;i<n-1;i++){
        int min=i;
        for(int j=i+1;j<n;j++)
            if(a[j]<a[min]) min=j;
        swap(a[i],a[min]);
    }
}

void insertionSort(int a[], int n) {
    for(int i=1;i<n;i++){
        int key=a[i], j=i-1;
        while(j>=0 && a[j]>key){
            a[j+1]=a[j];
            j--;
        }
        a[j+1]=key;
    }
}

int main() {
    int prices[] = {4500, 2000, 3500, 5000, 3000};
    int n = 5;
    int a1[5], a2[5], a3[5];

    // copy same data
    for(int i=0;i<n;i++){
        a1[i]=a2[i]=a3[i]=prices[i];
    }

    clock_t t;

    t = clock();
    bubbleSort(a1,n);
    cout<<"Bubble Sort Time: "<<(double)(clock()-t)/CLOCKS_PER_SEC<<endl;

    t = clock();
    selectionSort(a2,n);
    cout<<"Selection Sort Time: "<<(double)(clock()-t)/CLOCKS_PER_SEC<<endl;

    t = clock();
    insertionSort(a3,n);
    cout<<"Insertion Sort Time: "<<(double)(clock()-t)/CLOCKS_PER_SEC<<endl;

    return 0;
}



#include <iostream>
using namespace std;

int partition(int a[], int low, int high) {
    int pivot = a[high];   // take last element as pivot
    int i = low - 1;

    for (int j = low; j < high; j++) {
        if (a[j] < pivot) {
            i++;
            int temp = a[i];
            a[i] = a[j];
            a[j] = temp;
        }
    }

    int temp = a[i + 1];
    a[i + 1] = a[high];
    a[high] = temp;

    return i + 1;
}

void quickSort(int a[], int low, int high) {
    if (low < high) {
        int pi = partition(a, low, high);
        quickSort(a, low, pi - 1);
        quickSort(a, pi + 1, high);
    }
}

int main() {
    int prices[] = {4500, 2000, 3500, 5000, 3000};
    int n = 5;

    quickSort(prices, 0, n - 1);

    cout << "Sorted Room Prices:\n";
    for (int i = 0; i < n; i++)
        cout << prices[i] << " ";

    return 0;
}









#include <iostream>
using namespace std;

#define SIZE 5

int queue[SIZE];
int front = -1, rear = -1;

// Enqueue (Passenger enters)
void enqueue(int passenger) {
    if ((rear + 1) % SIZE == front) {
        cout << "Queue is Full (Bus Counter Busy)\n";
        return;
    }

    if (front == -1)
        front = 0;

    rear = (rear + 1) % SIZE;
    queue[rear] = passenger;

    cout << "Passenger " << passenger << " entered queue\n";
}

// Dequeue (Passenger exits)
void dequeue() {
    if (front == -1) {
        cout << "Queue is Empty\n";
        return;
    }

    cout << "Passenger " << queue[front] << " exited queue\n";

    if (front == rear) {
        front = rear = -1;  // queue becomes empty
    } else {
        front = (front + 1) % SIZE;
    }
}

// Display queue
void display() {
    if (front == -1) {
        cout << "Queue is Empty\n";
        return;
    }

    cout << "Passengers in queue: ";
    int i = front;
    while (true) {
        cout << queue[i] << " ";
        if (i == rear)
            break;
        i = (i + 1) % SIZE;
    }
    cout << endl;
}

int main() {
    enqueue(101);
    enqueue(102);
    enqueue(103);
    display();

    dequeue();
    display();

    enqueue(104);
    enqueue(105);
    display();

    return 0;
}



#include <iostream>
using namespace std;

struct Song {
    string name;
    Song* prev;
    Song* next;
};

Song* head = NULL;
Song* current = NULL;

// Add song at end
void addSong(string name) {
    Song* newSong = new Song();
    newSong->name = name;
    newSong->next = NULL;
    newSong->prev = NULL;

    if (head == NULL) {
        head = current = newSong;
    } else {
        Song* temp = head;
        while (temp->next != NULL)
            temp = temp->next;
        temp->next = newSong;
        newSong->prev = temp;
    }
}

// Play current
void play() {
    if (current)
        cout << "Playing: " << current->name << endl;
}

// Next song
void nextSong() {
    if (current && current->next)
        current = current->next;
    play();
}

// Previous song
void prevSong() {
    if (current && current->prev)
        current = current->prev;
    play();
}

int main() {
    addSong("Song A");
    addSong("Song B");
    addSong("Song C");

    play();
    nextSong();
    nextSong();
    prevSong();

    return 0;
}






#include <iostream>
using namespace std;

struct Node {
    int id;
    Node* left;
    Node* right;
};

// Create new patient
Node* newNode(int id) {
    Node* temp = new Node();
    temp->id = id;
    temp->left = temp->right = NULL;
    return temp;
}

// Insert patient
Node* insert(Node* root, int id) {
    if (root == NULL)
        return newNode(id);

    if (id < root->id)
        root->left = insert(root->left, id);
    else if (id > root->id)
        root->right = insert(root->right, id);

    return root;
}

// Search patient
bool search(Node* root, int id) {
    if (root == NULL)
        return false;

    if (root->id == id)
        return true;

    if (id < root->id)
        return search(root->left, id);
    else
        return search(root->right, id);
}

// Find minimum value node
Node* findMin(Node* root) {
    while (root->left != NULL)
        root = root->left;
    return root;
}

// Delete patient
Node* deleteNode(Node* root, int id) {
    if (root == NULL)
        return root;

    if (id < root->id)
        root->left = deleteNode(root->left, id);
    else if (id > root->id)
        root->right = deleteNode(root->right, id);
    else {
        // one or no child
        if (root->left == NULL)
            return root->right;
        else if (root->right == NULL)
            return root->left;

        // two children
        Node* temp = findMin(root->right);
        root->id = temp->id;
        root->right = deleteNode(root->right, temp->id);
    }
    return root;
}

// Inorder traversal
void inorder(Node* root) {
    if (root != NULL) {
        inorder(root->left);
        cout << root->id << " ";
        inorder(root->right);
    }
}

int main() {
    Node* root = NULL;

    root = insert(root, 50);
    insert(root, 30);
    insert(root, 70);
    insert(root, 20);
    insert(root, 40);

    cout << "Patient IDs: ";
    inorder(root);

    cout << "\nSearching 40: ";
    cout << (search(root, 40) ? "Found" : "Not Found");

    root = deleteNode(root, 30);

    cout << "\nAfter deleting 30: ";
    inorder(root);

    return 0;
}




#include <iostream>
#include <vector>
#include <queue>
using namespace std;

int main() {
    int users = 5;
    vector<int> graph[6];

    // Friend connections
    graph[1].push_back(2);
    graph[2].push_back(1);

    graph[1].push_back(3);
    graph[3].push_back(1);

    graph[2].push_back(4);
    graph[4].push_back(2);

    graph[3].push_back(5);
    graph[5].push_back(3);

    int start = 1;

    vector<bool> visited(6, false);
    vector<int> level(6, -1);

    queue<int> q;
    q.push(start);
    visited[start] = true;
    level[start] = 0;

    // BFS
    while (!q.empty()) {
        int u = q.front();
        q.pop();

        for (int v : graph[u]) {
            if (!visited[v]) {
                visited[v] = true;
                level[v] = level[u] + 1;
                q.push(v);
            }
        }
    }

    cout << "Friend suggestions for user " << start << ":\n";
    for (int i = 1; i <= users; i++) {
        if (level[i] == 2) {
            cout << i << " ";
        }
    }

    return 0;
}






#include <iostream>
using namespace std;

int main() {
    int n = 5;
    int table[10];

    // initialize hash table with -1
    for (int i = 0; i < 10; i++)
        table[i] = -1;

    int skus[] = {101, 205, 330, 412, 101}; // duplicate included

    // INSERT using Linear Probing
    for (int i = 0; i < n; i++) {
        int key = skus[i];
        int index = key % 10;

        while (table[index] != -1) {
            index = (index + 1) % 10;  // linear probing
        }
        table[index] = key;
    }

    // SEARCH
    int searchKey = 330;
    int index = searchKey % 10;
    int start = index;

    while (table[index] != -1) {
        if (table[index] == searchKey) {
            cout << "SKU " << searchKey << " found at index " << index;
            return 0;
        }
        index = (index + 1) % 10;
        if (index == start) break;
    }

    cout << "SKU not found";
    return 0;
}






#include <iostream>
using namespace std;

// Merge two sorted parts
void merge(int a[], int l, int m, int r) {
    int i = l, j = m + 1, k = 0;
    int temp[20];

    while (i <= m && j <= r) {
        if (a[i] < a[j])
            temp[k++] = a[i++];
        else
            temp[k++] = a[j++];
    }

    while (i <= m)
        temp[k++] = a[i++];

    while (j <= r)
        temp[k++] = a[j++];

    for (int i = l, k = 0; i <= r; i++, k++)
        a[i] = temp[k];
}

// Merge Sort
void mergeSort(int a[], int l, int r) {
    if (l < r) {
        int m = (l + r) / 2;
        mergeSort(a, l, m);
        mergeSort(a, m + 1, r);
        merge(a, l, m, r);
    }
}

int main() {
    int books[] = {45, 12, 78, 34, 23};
    int n = 5;

    mergeSort(books, 0, n - 1);

    cout << "Sorted Book IDs:\n";
    for (int i = 0; i < n; i++)
        cout << books[i] << " ";

    return 0;
}






#include <iostream>
using namespace std;

int main() {
    string backStack[10], forwardStack[10];
    int backTop = -1, forwardTop = -1;

    string current = "Home";
    cout << "Current Page: " << current << endl;

    // Visit Page A
    backStack[++backTop] = current;
    current = "PageA";
    forwardTop = -1;   // clear forward stack
    cout << "Visited: " << current << endl;

    // Visit Page B
    backStack[++backTop] = current;
    current = "PageB";
    forwardTop = -1;
    cout << "Visited: " << current << endl;

    // Back operation
    forwardStack[++forwardTop] = current;
    current = backStack[backTop--];
    cout << "After Back: " << current << endl;

    // Forward operation
    backStack[++backTop] = current;
    current = forwardStack[forwardTop--];
    cout << "After Forward: " << current << endl;

    return 0;
}






#include <iostream>
using namespace std;

struct Case {
    int id;
    int priority;
};

int main() {
    Case pq[10];
    int n = 0;

    // Insert cases
    pq[n++] = {101, 3};
    pq[n++] = {102, 5};
    pq[n++] = {103, 1};
    pq[n++] = {104, 4};

    // Sort by priority (descending)
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (pq[i].priority < pq[j].priority) {
                Case temp = pq[i];
                pq[i] = pq[j];
                pq[j] = temp;
            }
        }
    }

    cout << "Ambulance Dispatch Order:\n";
    for (int i = 0; i < n; i++) {
        cout << "Case ID: " << pq[i].id
             << " Priority: " << pq[i].priority << endl;
    }

    return 0;
}






#include <iostream>
using namespace std;

#define MAX 5

int stack[MAX];
int top = -1;

// Push operation
void push(int bookID) {
    if (top == MAX - 1) {
        cout << "Bin is full\n";
        return;
    }
    top++;
    stack[top] = bookID;
    cout << "Book " << bookID << " returned\n";
}

// Pop operation
void pop() {
    if (top == -1) {
        cout << "Bin is empty\n";
        return;
    }
    cout << "Processing book " << stack[top] << endl;
    top--;
}

int main() {
    push(101);
    push(102);
    push(103);

    pop();
    pop();

    return 0;
}





#include <iostream>
using namespace std;

struct Parcel {
    int trackNo;
    Parcel* next;
};

int SIZE = 5;
Parcel* table[5];

// Hash function
int hashFunc(int key) {
    return key % SIZE;
}

// Insert parcel
void insert(int key) {
    int index = hashFunc(key);

    Parcel* newNode = new Parcel();
    newNode->trackNo = key;
    newNode->next = table[index];

    table[index] = newNode;
}

// Display parcels
void display() {
    for (int i = 0; i < SIZE; i++) {
        cout << "Index " << i << ": ";
        Parcel* temp = table[i];
        while (temp != NULL) {
            cout << temp->trackNo << " -> ";
            temp = temp->next;
        }
        cout << "NULL\n";
    }
}

int main() {
    for (int i = 0; i < SIZE; i++)
        table[i] = NULL;

    insert(101);
    insert(206);
    insert(311);
    insert(416);
    insert(521);   // causes collision

    display();
    return 0;
}





#include <iostream>
using namespace std;

int graph[5][5] = {
    {0,1,1,0,0},
    {1,0,0,1,0},
    {1,0,0,0,1},
    {0,1,0,0,0},
    {0,0,1,0,0}
};

int visited[5] = {0};

void DFS(int node) {
    cout << node << " ";
    visited[node] = 1;

    for(int i = 0; i < 5; i++) {
        if(graph[node][i] == 1 && visited[i] == 0) {
            DFS(i);
        }
    }
}

int main() {
    cout << "Food Delivery Route (DFS): ";
    DFS(0);   // start from restaurant
    return 0;
}




#include <iostream>
using namespace std;

int graph[5][5] = {
    {0,1,1,0,0},
    {1,0,0,1,0},
    {1,0,0,0,1},
    {0,1,0,0,0},
    {0,0,1,0,0}
};

int visited[5] = {0};
int queue[5];
int front = 0, rear = 0;

void BFS(int start) {
    queue[rear++] = start;
    visited[start] = 1;

    while(front < rear) {
        int node = queue[front++];
        cout << node << " ";

        for(int i = 0; i < 5; i++) {
            if(graph[node][i] == 1 && visited[i] == 0) {
                queue[rear++] = i;
                visited[i] = 1;
            }
        }
    }
}

int main() {
    cout << "Shortest Food Delivery Route (BFS): ";
    BFS(0);   // restaurant
    return 0;
}





#include <iostream>
#include <string>
using namespace std;

int main() {
    string type[4] = {"Deposit", "Withdraw", "Deposit", "Withdraw"};
    int amount[4]  = {500, 200, 1000, 300};

    int front = 0, rear = 3;   // queue indexes
    int balance = 0;

    cout << "Processing Bank Transactions:\n";

    while (front <= rear) {
        if (type[front] == "Deposit") {
            balance = balance + amount[front];
            cout << "Deposited: " << amount[front] << endl;
        }
        else {
            balance = balance - amount[front];
            cout << "Withdrawn: " << amount[front] << endl;
        }
        front++;   // move queue forward
    }

    cout << "Final Balance: " << balance << endl;

    return 0;
}






#include <iostream>
using namespace std;

// Insertion Sort
void insertionSort(int a[], int n) {
    for(int i = 1; i < n; i++) {
        int key = a[i];
        int j = i - 1;
        while(j >= 0 && a[j] > key) {
            a[j + 1] = a[j];
            j--;
        }
        a[j + 1] = key;
    }
}

// Selection Sort
void selectionSort(int a[], int n) {
    for(int i = 0; i < n - 1; i++) {
        int min = i;
        for(int j = i + 1; j < n; j++) {
            if(a[j] < a[min])
                min = j;
        }
        int temp = a[i];
        a[i] = a[min];
        a[min] = temp;
    }
}

int main() {
    int times1[] = {930, 845, 1200, 1015, 900};
    int times2[] = {930, 845, 1200, 1015, 900};
    int n = 5;

    insertionSort(times1, n);
    selectionSort(times2, n);

    cout << "Insertion Sort Result:\n";
    for(int i = 0; i < n; i++)
        cout << times1[i] << " ";

    cout << "\n\nSelection Sort Result:\n";
    for(int i = 0; i < n; i++)
        cout << times2[i] << " ";

    return 0;
}






#include <iostream>
using namespace std;
// Node structure for polynomial terms
struct Node {
int coeff; // coefficient
int pow; // power
Node* next;
};
// Function to create a new node
Node* createNode(int coeff, int pow) {
Node* newNode = new Node();
newNode->coeff = coeff;
newNode->pow = pow;
newNode->next = NULL;
return newNode;
}
// Function to insert a new term into the polynomial
void insert(Node*& poly, int coeff, int pow) {
Node* newNode = createNode(coeff, pow);
if (!poly)
poly = newNode;
else {
Node* temp = poly;
while (temp->next)
temp = temp->next;
temp->next = newNode;
}
}
// Function to add two polynomials
Node* addPoly(Node* poly1, Node* poly2) {
Node* result = NULL;
while (poly1 && poly2) {
if (poly1->pow > poly2->pow) {
insert(result, poly1->coeff, poly1->pow);
poly1 = poly1->next;
} else if (poly1->pow < poly2->pow) {
insert(result, poly2->coeff, poly2->pow);
poly2 = poly2->next;
} else {
insert(result, poly1->coeff + poly2->coeff, poly1->pow);
poly1 = poly1->next;
poly2 = poly2->next;
}
}
// Remaining terms
while (poly1) {
insert(result, poly1->coeff, poly1->pow);
poly1 = poly1->next;
}

while (poly2) {
insert(result, poly2->coeff, poly2->pow);
poly2 = poly2->next;
}
return result;
}
// Function to display polynomial
void display(Node* poly) {
while (poly) {
cout << poly->coeff << "x^" << poly->pow;
if (poly->next)
cout << " + ";
poly = poly->next;
}
cout << endl;
}
int main() {
Node *poly1 = NULL, *poly2 = NULL, *result = NULL;
// First polynomial: 5x^2 + 4x^1 + 2
insert(poly1, 5, 2);
insert(poly1, 4, 1);
insert(poly1, 2, 0);
// Second polynomial: 5x^1 + 5
insert(poly2, 5, 1);
insert(poly2, 5, 0);
cout << "Polynomial 1: ";
display(poly1);
cout << "Polynomial 2: ";
display(poly2);
result = addPoly(poly1, poly2);
cout << "Resultant Polynomial after addition: ";
display(result);
return 0;
}






#include <iostream>
#include <vector>
#include <queue>
#include <map>
using namespace std;

int main() {
    // Map building names to numbers
    map<string, int> id;
    id["Library"] = 0;
    id["Canteen"] = 1;
    id["Lab"] = 2;
    id["Admin"] = 3;
    id["Hostel"] = 4;

    // Reverse map (number to name)
    string name[5] = {"Library", "Canteen", "Lab", "Admin", "Hostel"};

    // Adjacency list
    vector<int> adj[5];

    // Connections
    adj[id["Library"]].push_back(id["Lab"]);
    adj[id["Lab"]].push_back(id["Library"]);

    adj[id["Lab"]].push_back(id["Hostel"]);
    adj[id["Hostel"]].push_back(id["Lab"]);

    adj[id["Canteen"]].push_back(id["Library"]);
    adj[id["Library"]].push_back(id["Canteen"]);

    adj[id["Admin"]].push_back(id["Hostel"]);
    adj[id["Hostel"]].push_back(id["Admin"]);

    // BFS
    queue<int> q;
    int visited[5] = {0};
    int parent[5] = {-1, -1, -1, -1, -1};

    int start = id["Canteen"];
    int end = id["Hostel"];

    q.push(start);
    visited[start] = 1;

    while (!q.empty()) {
        int curr = q.front();
        q.pop();

        for (int next : adj[curr]) {
            if (!visited[next]) {
                visited[next] = 1;
                parent[next] = curr;
                q.push(next);
            }
        }
    }

    // Print shortest path
    cout << "Shortest Path: ";
    int temp = end;
    while (temp != -1) {
        cout << name[temp] << " <- ";
        temp = parent[temp];
    }

    return 0;
}





#include <iostream>
using namespace std;

int queue[10];
int front = 0, rear = -1;

// Add parcel
void enqueue(int parcel) {
    rear++;
    queue[rear] = parcel;
}

// Process parcel
void dequeue() {
    cout << "Processed Parcel: P" << queue[front] << endl;
    front++;
}

int main() {
    // Enter parcels
    enqueue(100);
    enqueue(102);
    enqueue(105);
    enqueue(110);

    cout << "Shipment Processing Order:\n";

    while (front <= rear) {
        dequeue();
    }

    return 0;
}






















